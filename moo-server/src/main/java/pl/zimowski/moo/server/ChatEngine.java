package pl.zimowski.moo.server;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.annotation.PreDestroy;
import javax.inject.Inject;

import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import pl.zimowski.moo.api.ApiUtils;
import pl.zimowski.moo.api.ClientEvent;

/**
 * Core implementation of chat server based on web sockets. Supports multiple
 * clients and tracks their connections. Orchestrates incoming messages by
 * broadcasting each received client message to all other clients (essance of
 * chat service).
*
 * @since 1.0.0
 * @author Adam Zimowski (<a href="mailto:mrazjava@yandex.com">mrazjava</a>)
 */
@Component
public class ChatEngine implements ChatService, ServerNotification {

    @Inject
    private Logger log;

    @Value("${port}")
    private int port;

    private boolean running;

    /**
     * each connected client will receive server events; this is the essence
     * of a chat server - ability to orchestrate events generated by clients
     * <p>
     * Note: this set is not thread safe so internal synchronization is needed
     * </p>
     */
    private Set<ClientNotification> connectedClients = new HashSet<>();


    @Override
    public void start() {

        log.info("\n{}", ApiUtils.fetchResource("/logo"));
        log.info("listening on port {}", port);

        try (ServerSocket server = new ServerSocket(port)) {
            listen(server);
        }
        catch (IOException e) {
            log.error("starting server on port {} failed: {}", port, e.getMessage());
        }
    }

    /**
     * Given established server socket, enters listening mode over it. Listens
     * for incoming client socket connections and if detected, immediatelly
     * spawns a processing thread to handle that client.
     *
     * @param serverSocket on which to listen
     */
    private void listen(ServerSocket serverSocket) {

        ExecutorService executor = Executors.newCachedThreadPool();
        running = true;

        while(running) {
            try {
                Socket socket = serverSocket.accept();
                log.info("recieved {}", socket);
                ClientThread client = new ClientThread(socket, this);
                synchronized(this) {
                    connectedClients.add(client);
                }
                log.debug("{} connected clients", connectedClients.size());
                executor.submit(client);
            }
            catch(IOException e) {
                log.error("unexpected problem; aborting!", e);
            }
        }
    }

    /**
     * @return number of clients currently connected
     */
    public int getConnectedClientCount() {
        return connectedClients.size();
    }

    @Override
    public void notify(ClientThread client, ClientEvent event) {
        log.debug("received: {} from {}", event, client);
    }

    @Override
    public boolean isRunning() {
        return running;
    }

    @Override
    public void stop() {
        running = false;
    }

    /**
     * Allows to override injected configured port value.
     *
     * @param port override to use instead of a configured one
     */
    public void setPort(int port) {
        this.port = port;
    }

    @PreDestroy
    public void shutdown() {
        log.info("shutting down; bye!");
    }
}