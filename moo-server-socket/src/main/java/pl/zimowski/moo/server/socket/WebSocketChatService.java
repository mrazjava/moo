package pl.zimowski.moo.server.socket;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.annotation.PreDestroy;
import javax.inject.Inject;

import org.apache.commons.lang3.StringUtils;
import org.joda.time.DateTime;
import org.joda.time.Seconds;
import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import pl.zimowski.moo.api.ApiUtils;
import pl.zimowski.moo.api.ClientAction;
import pl.zimowski.moo.api.ClientEvent;
import pl.zimowski.moo.api.ServerAction;
import pl.zimowski.moo.api.ServerEvent;
import pl.zimowski.moo.server.commons.ChatService;
import pl.zimowski.moo.server.commons.EventManager;
import pl.zimowski.moo.server.commons.jmx.JmxReportingSupport;

/**
 * Core implementation of chat server based on web sockets. Supports multiple
 * clients and tracks their connections. Orchestrates incoming messages by
 * broadcasting each received client message to all other clients (essance of
 * chat service).
*
 * @since 1.0.0
 * @author Adam Zimowski (<a href="mailto:mrazjava@yandex.com">mrazjava</a>)
 */
@Component
public class WebSocketChatService implements ChatService, EventBroadcasting {
	
    @Inject
    private Logger log;
    
    @Inject
    private ServerSocketFactory serverSocketFactory;

    @Value("${port}")
    private int port;

    @Value("${evictionTimeout}")
    private Integer evictionTimeout;

    private boolean running;

    @Inject
    private JmxReportingSupport jmxReporter;

    @Inject
    private EventManager eventManager;

    /**
     * each connected client will receive server events; this is the essence
     * of a chat server - ability to orchestrate events generated by clients
     * <p>
     * Note: this set is not thread safe so internal synchronization is needed
     * </p>
     */
    private Set<ClientNotification> connectedClients = new HashSet<>();


    @Override
    public void start() {

        log.info("\n{}", ApiUtils.fetchResource("/logo"));
        log.info("listening on port {} (ctrl-c to exit)", port);

        try (ServerSocket server = serverSocketFactory.getServerSocket(port)) {
            listen(server);
        }
        catch (IOException e) {
            log.error("starting server on port {} failed: {}", port, e.getMessage());
        }
    }

    /**
     * Given established server socket, enters listening mode over it. Listens
     * for incoming client socket connections and if detected, immediatelly
     * spawns a processing thread to handle that client.
     *
     * @param serverSocket on which to listen
     */
    private void listen(ServerSocket serverSocket) {

        ExecutorService executor = Executors.newCachedThreadPool();
        running = true;

        while(running) {
            try {
                Socket socket = serverSocket.accept();
                log.info("received {}", socket);
                ClientThread client = new ClientThread(socket, this);
                synchronized(this) {
                    connectedClients.add(client);
                }
                jmxReporter.clientConnected();
                log.debug("connections: {}, participants: {}", connectedClients.size(), eventManager.getParticipantCount());
                executor.submit(client);
                client.notify(new ServerEvent(ServerAction.ConnectionEstablished)
                        .withClientId(client.getClientId())
                        );
                client.notify(new ServerEvent(ServerAction.ParticipantCount)
                		.withMessage(String.format("%d participant(s)", eventManager.getParticipantCount()))
                		);
            }
            catch(IOException e) {
                log.error("unexpected problem; aborting!", e);
            }
        }
    }

    /**
     * @return number of clients currently connected
     */
    public int getConnectedClientCount() {
        return connectedClients.size();
    }

	@Override
    public int broadcast(ClientThread clientThread, ClientEvent clientEvent) {

        evictInactiveClients();

        log.debug("broadcasting {} from {}", clientEvent, clientThread);

        if(clientEvent.getAction() == ClientAction.Disconnect) {
        	connectedClients.remove(clientThread);
        }
        
        ServerEvent serverEvent = eventManager.clientEventToServerEvent(clientEvent);
        
        if(clientEvent.getAction() == ClientAction.GenerateNick) {
        	clientThread.notify(serverEvent);
        	return 1; // only nick requestor gets notified with generated nick
        }
        if(clientEvent.getAction() == ClientAction.Signin) {
        	clientThread.notify(
        			new ServerEvent(ServerAction.SigninConfirmed)
        				.withAuthor(clientEvent.getAuthor())
        				);
        }
        clientThread.notify(serverEvent);
        
        return broadcast(clientThread, serverEvent);
    }
    
    private int broadcast(ClientNotification source, ServerEvent event) {
    	        
        int notifiedClients = 0;

        // could be perf bottleneck - should re-think for optimization; this
        // needs to be thread safe as otherwise iterator would get screwed up
        // and event delivery unpredictable (events eaten out)
        synchronized(this) {
            // standard message broadcast
            for(ClientNotification connectedClient : connectedClients) {

                if(source != null && StringUtils.equals(source.getClientId(), connectedClient.getClientId()))
                    continue;
                
                log.debug("broadcasting to: {}", connectedClient);

                if(connectedClient.notify(event)) {
                    notifiedClients++;
                }
            }
        }

        log.debug("nofied {} clients", notifiedClients);

        return notifiedClients;
    }

    private synchronized void evictInactiveClients() {

        for(Iterator<ClientNotification> iterator = connectedClients.iterator(); iterator.hasNext();) {

            ClientNotification connectedClient = iterator.next();
            DateTime lastActive = new DateTime(connectedClient.getLastActivity());
            int inactiveSeconds = Seconds.secondsBetween(lastActive, new DateTime()).getSeconds();

            if(evictionTimeout != null && inactiveSeconds >= evictionTimeout) {
                log.info("{} inactive for {} seconds, evicting!", connectedClient, inactiveSeconds);
                connectedClient.notify(new ServerEvent(ServerAction.ConnectionTimeOut).withMessage("disconnected due to inactivity"));
                connectedClient.disconnect();
                iterator.remove();
                eventManager.decrementParticipantCount();
                continue;
            }
        }
    }

    @Override
    public boolean isRunning() {
        return running;
    }

    @Override
    public void stop() {
        running = false;
    }

    /**
     * Allows to override injected configured port value.
     *
     * @param port override to use instead of a configured one
     */
    public void setPort(int port) {
        this.port = port;
    }

    @PreDestroy
    public void shutdown() {
    	broadcast(null, new ServerEvent(ServerAction.ServerExit).withMessage("deliberate server shutdown"));
        log.debug("engine shutdown ({} clients, {} participants)", getConnectedClientCount(), eventManager.getParticipantCount());
    }
}